%% @copyright 2011 Zuse Institute Berlin

%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%
%       http://www.apache.org/licenses/LICENSE-2.0
%
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.

%% @author Nico Kruber <kruber@zib.de>
%% @doc Thin layer on top of the rdht_tx implementing higher-order functions
%%      for request lists (used by api_tx).
%%      Should possibly be merged with rdht_tx but is kept separately for
%%      simplicity of implementing additional functions.
%% @end
%% @version $Id$
-module(rdht_tx0).
-author('kruber@zib.de').
-vsn('$Id$').

%% Perform a chain of operations (passing a transaction log) and
%% finally commit the transaction.
-export([req_list/2]).

-include("scalaris.hrl").
-include("client_types.hrl").

%% conversion between ?DB:value() and client_value():
-export([encode_value/1, decode_value/1]).

%% @doc Pre-processes the given request list by encoding all values of write
%%      requests and checking whether the commit requests are correct.
%%      If the commits are not correct, AbortCommits will be set to true.
-spec preprocess_req_list(Orig::[api_tx:request()], NewRev::[api_tx:request()], AbortCommits::boolean())
        -> {New::[api_tx:request()], AbortCommits::boolean()}.
preprocess_req_list([], New, AbortCommits) ->
    {lists:reverse(New), AbortCommits};
preprocess_req_list([{commit}], New, AbortCommits) ->
    {lists:reverse([{commit} | New]), AbortCommits};
preprocess_req_list([Req | Rest], New, AbortCommits) ->
    case Req of
        {write, Key, Value} ->
            preprocess_req_list(Rest, [{write, Key, encode_value(Value)} | New], AbortCommits);
        {commit} ->
            log:log(warn, "Commit not at end of a request list. Deciding abort."),
            preprocess_req_list(Rest, [{commit} | New], true);
        Op ->
            preprocess_req_list(Rest, [Op | New], AbortCommits)
    end.

%% @doc Phase 1 takes requests sorted by the key (commit requests are not
%%      allowed) and creates a new request list which only contains the first
%%      operation per key.
%%      For higher-level functions which require a read first and (later) add
%%      a write, a read operation is issued.
-spec map_phase1(Requests::[api_tx:request_on_key()], LastKey::client_key() | unknown,
                 FirstReqs::[rdht_tx:request_on_key()]) -> FirstReqs::[rdht_tx:request_on_key()].
map_phase1([], _LastKey, FirstReqs) ->
    lists:reverse(FirstReqs);
map_phase1([Request | Rest], LastKey, FirstReqs) when element(2, Request) =:= LastKey ->
    map_phase1(Rest, LastKey, FirstReqs);
map_phase1([Request | Rest], _LastKey, FirstReqs) ->
    % note: replaced operations by corresponding module names in ReqList
    % number requests in ReqList to keep ordering more easily
    case Request of
        % common cases first:
        {read, Key} ->
            map_phase1(Rest, Key, [{rdht_tx_read, Key} | FirstReqs]);
        {write, Key, Value} ->
            map_phase1(Rest, Key, [{rdht_tx_write, Key, Value} | FirstReqs]);
        % special (2-steps) functions:
        {set_change, Key, _ToAdd, _ToRemove} ->
            map_phase1(Rest, Key, [{rdht_tx_read, Key} | FirstReqs]);
        {number_add, Key, _X} ->
            map_phase1(Rest, Key, [{rdht_tx_read, Key} | FirstReqs]);
        {test_and_set, Key, _Old, _New} ->
            map_phase1(Rest, Key, [{rdht_tx_read, Key} | FirstReqs])
    end.

%% @doc Manipulate tlog to contain the given status for the given key (if present).
-spec set_tlog_status_at_key(TLog::tx_tlog:tlog(), Key::client_key(), Status::tx_tlog:tx_status()) -> tx_tlog:tlog().
set_tlog_status_at_key(TLog, Key, Status) ->
    tx_tlog:update_status_by_key(TLog, Key, {fail, Status}).

%% @doc Phase 2 uses the the TLog generated by executing the requests of
%%      phase 1 and executes all requests in their original order upon it.
%%      Since everything should be in the TLog, this should not cause any
%%      communication with remote processes.
-spec map_phase2(Requests::[api_tx:request()], TLog::tx_tlog:tlog(), Results::[api_tx:result()], AbortCommits::boolean())
        -> {TLog::tx_tlog:tlog(), Results::[api_tx:result()]}.
map_phase2([], TLog0, Results0, _AbortCommits) ->
    {TLog0, lists:reverse(Results0)};
map_phase2([{commit} = Op], TLog0, Results0, false) ->
    {TLogX, ResultX} = single_req(TLog0, Op),
    {TLogX, lists:reverse([ResultX | Results0])};
map_phase2([Request | Rest], TLog0, Results0, AbortCommits) ->
    % note: replaced operations by corresponding module names in ReqList
    % number requests in ReqList to keep ordering more easily
    % note: all requests only operate on the translog (rest was done in phase1)
    {TLogX, ResultX} =
        case Request of
            % common cases first:
            {read, Key} ->
                single_req(TLog0, {rdht_tx_read, Key});
            {write, Key, Value} ->
                single_req(TLog0, {rdht_tx_write, Key, Value});
            {commit} when AbortCommits ->
                {TLog0, {fail, abort}};
            % special functions:
            {set_change, Key, ToAdd, ToRemove} ->
                {TLog1, Result1} = single_req(TLog0, {rdht_tx_read, Key}),
                case Result1 of
                    _ when (not erlang:is_list(ToAdd)) orelse
                               (not erlang:is_list(ToRemove)) ->
                        Error = {fail, not_a_list},
                        {set_tlog_status_at_key(TLog1, Key, Error), Error};
                    {ok, OldValue} when erlang:is_list(OldValue) ->
                        case ToAdd =:= [] andalso ToRemove =:= [] of
                            true -> {TLog1, {ok}}; % no op
                            _ ->
                                NewValue1 = lists:append(ToAdd, OldValue),
                                NewValue2 = util:minus(NewValue1, ToRemove),
                                single_req(TLog1, {rdht_tx_write, Key, encode_value(NewValue2)})
                        end;
                    {fail, not_found} ->
                        NewValue2 = util:minus(ToAdd, ToRemove),
                        single_req(TLog1, {rdht_tx_write, Key, encode_value(NewValue2)});
                    {ok, _} ->
                        Error = {fail, not_a_list},
                        {set_tlog_status_at_key(TLog1, Key, Error), Error};
                    X when erlang:is_tuple(X) ->
                        {TLog1, X}
                end;
            {number_add, Key, X} ->
                {TLog1, Result1} = single_req(TLog0, {rdht_tx_read, Key}),
                case Result1 of
                    _ when (not erlang:is_number(X)) ->
                        Error = {fail, not_a_number},
                        {set_tlog_status_at_key(TLog1, Key, Error), Error};
                    {ok, OldValue} when erlang:is_number(OldValue) ->
                        case X == 0 of % also accepts 0.0
                            true -> {TLog1, {ok}}; % no op
                            _ ->
                                NewValue = OldValue + X,
                                single_req(TLog1, {rdht_tx_write, Key, encode_value(NewValue)})
                        end;
                    {fail, not_found} ->
                        NewValue = X,
                        single_req(TLog1, {rdht_tx_write, Key, encode_value(NewValue)});
                    {ok, _} ->
                        Error = {fail, not_a_number},
                        {set_tlog_status_at_key(TLog1, Key, Error), Error};
                    E when erlang:is_tuple(E) ->
                        {TLog1, E}
                end;
            {test_and_set, Key, Old, New} ->
                {TLog1, Result1} = single_req(TLog0, {rdht_tx_read, Key}),
                case Result1 of
                    {ok, Old} ->
                        single_req(TLog1, {rdht_tx_write, Key, encode_value(New)});
                    {ok, RealOldValue} ->
                        Error = {fail, {key_changed, RealOldValue}},
                        {set_tlog_status_at_key(TLog1, Key, Error), Error};
                    X when erlang:is_tuple(X) ->
                        {TLog1, X}
                end
        end,
    map_phase2(Rest, TLogX, [ResultX | Results0], AbortCommits).

%% @doc Perform several requests inside a transaction.
-spec req_list(tx_tlog:tlog(), [api_tx:request()]) -> {tx_tlog:tlog(), [api_tx:result()]}.
req_list([], [{commit}]) ->
    {[], [{ok}]};
req_list(TLog, ReqList) ->
    %% sanity checks on ReqList:
    % first encode values (prevents duplicate encoding of write values)
    % also check number of {commit} requests, commit only at the end of reqlist!
    {ReqList1, AbortCommits} = preprocess_req_list(ReqList, [], false),

    %% phase1
    % remove all commits (we do not want to commit the tx in phase1)
    ReqList2 = [Req || Req <- ReqList1, Req =/= {commit}],
    % build translog with all first operations per key:
    % note: key is always the second element of any request tuple
    ReqList3 = lists:keysort(2, ReqList2),
    % only keep the first request per key and (later) create translog with them:
    RDHT_ReqList4 = map_phase1(ReqList3, unknown, []),
    % @TODO should choose a dht_node in the local VM at random or even
    % better round robin.
    % @TODO Scan for fail in TransLog, then return immediately?
    % ignore results - they will be collected during phase2
    {NewTLog, _Results} = rdht_tx:req_list(TLog, RDHT_ReqList4),
    
    %% phase2:
    % transform 2-step operations, execute requests and collect results
    map_phase2(ReqList1, NewTLog, [], AbortCommits).

%% @doc Perform several requests inside a transaction (internal implementation).
-spec single_req(tx_tlog:tlog(), rdht_tx:request()) -> {tx_tlog:tlog(), api_tx:result()}.
single_req([], {commit}) ->
    {[], {ok}};
single_req(TLog, Req) ->
    {NewTLog, [Result]} = rdht_tx:req_list(TLog, [Req]),
    {NewTLog, decode_rdht_result(Result)}.

%% @doc Encodes the given client value to its internal representation which is
%%      compressed for all values except atom, boolean, number or binary.
-spec encode_value(client_value()) -> ?DB:value().
encode_value(Value) when is_atom(Value) orelse is_boolean(Value) orelse
                             is_number(Value) ->
    Value;
encode_value(Value) when is_binary(Value) ->
    % do not compress a binary
    erlang:term_to_binary(Value, [{minor_version, 1}]);
encode_value(Value) ->
    erlang:term_to_binary(Value, [{compressed, 6}, {minor_version, 1}]).

%% @doc Decodes the given internal representation of a client value.
-spec decode_value(?DB:value()) -> client_value().
decode_value(Value) when is_binary(Value) ->
    erlang:binary_to_term(Value);
decode_value(Value) ->
    Value.

%% @doc Decodes a result from an operation (includes decoding of a client value
%%      if present).
-spec decode_rdht_result(rdht_tx:result_entry()) -> api_tx:result().
decode_rdht_result({ok, Value}) -> {ok, decode_value(Value)};
decode_rdht_result(X) -> X.
